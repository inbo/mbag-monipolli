---
title: "Exploratory data analysis SPRING"
author: "Emma Cartuyvels, Hans Van Calster"
date: "2024-05-02"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---
# Inleiding

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(message = FALSE, warning = FALSE)

library(RODBC)
library(readxl)
library(dataMaid)
library(vegan)
library(ggvenn)
library(plotly)
library(kableExtra)
library(glmmTMB)
library(sf)
library(dplyr)
library(tidyr)
library(purrr)
library(here)
library(lubridate)
library(stringr)
library(googlesheets4)

conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("layout", "plotly")
```

```{r venn-function}
venn <- function(data, group, count_id = "species_nm") {
  groups <- data %>%
    distinct(!!sym(group)) %>%
    pull(!!sym(group))
  
  x <- vector(mode = "list", length = length(groups))
  x <- setNames(x, groups)
  
  for (i in groups) {
    int <- data %>%
      filter(
        time_series == 0,
        !!sym(group) == i
      ) %>%
      distinct(!!sym(count_id)) %>%
      filter(!is.na(!!sym(count_id))) %>%
      pull(!!sym(count_id))
    x[[i]] <- int
  }
  
  ggVennDiagram::ggVennDiagram(x) +
    scale_x_continuous(expand = c(0.2, 0.2))
}
```

```{r rarefaction-function}
rarefaction <- function(data) {
  rrf <- data %>%
    pivot_wider(
      names_from = species_nm,
      values_from = n,
      values_fill = 0
    ) %>%
    select(-1) %>%
    specaccum(method = "rarefaction")

  data.frame(
    sites = rrf[["sites"]],
    richness = rrf[["richness"]],
    individuals = rrf[["individuals"]],
    sd = rrf[["sd"]]
  ) %>%
    mutate(
      lwr = richness - 2 * sd,
      upr = richness + 2 * sd
    ) # sd standard error of the estimate
}
```

Er zijn vier tabellen in de access database:

- Identificaties van de soorten
- Unieke samples
- Sample locaties
- Natural history traits van wilde bijsoorten

Van de eerste twee tabellen wordt een versimpelde versie gemaakt.

```{r load-data}
conn <- odbcConnectAccess2007(here("data/SPRING.accdb"))

identifications <- sqlFetch(conn, "identifications")
samples <- sqlFetch(conn, "samples")
sampling_sites <- sqlFetch(conn, "sampling_sites")
naturalhistorytraits <- sqlFetch(conn, "Wildbees_naturalhistorytraits")
RODBC::odbcClose(conn)
```

```{r}
identifications <- identifications %>%
  janitor::clean_names() %>%
  as_tibble() %>%
  rename(
    no_ind = "no_males_females",
    species_nm = "species_nm_author_year"
  ) %>%
  rename(
    family = familiy
  )

samples <- samples %>%
  janitor::clean_names() %>%
  as_tibble() %>%
  mutate(
    date_b = lubridate::as_date(date_b),
    date_e = lubridate::as_date(date_e)
  )

sampling_sites <- sampling_sites %>%
  janitor::clean_names() %>%
  as_tibble() %>%
  mutate(
    method_cd = stringr::str_extract(sampling_site_cd, "(TS|PT)")
  )

naturalhistorytraits <- naturalhistorytraits %>%
  janitor::clean_names() %>%
  as_tibble()

identifications_basic <- identifications %>%
  as_tibble() %>%
  select(
    sample_code,
    species_nm,
    family,
    order,
    functional_group,
    no_ind
  ) %>%
  group_by(sample_code,
    species_nm,
    family,
    order,
    functional_group) %>%
  summarise(
    no_ind = sum(no_ind),
    .groups = "drop"
  ) %>% 
  mutate(group = case_when(
    family %in% c(
        "Apidae", "Andrenidae",
        "Colletidae", "Halictidae",
        "Melittidae", "Megachilidae") ~ "Apoidea",
    family == "Syrphidae" ~ "Syrphidae",
    .default = "other"
  ))

samples_basic <- samples %>%
  distinct(
    sample_code,
    location_code,
    sampling_site_cd,
    method_cd,
    spring_code,
    time_series,
    level,
    date_b,
    date_e
  ) %>%
  group_by(
    location_code, sampling_site_cd, method_cd, spring_code, level
  ) %>%
  mutate(
    month = lubridate::month(date_b),
    duration = date_e - date_b,
    time_order = order(date_b),
        uv = case_when(
      spring_code == "MP" & method_cd == "PT" ~ "non-uv",
      spring_code != "MP" & method_cd == "PT" ~ "uv",
      TRUE ~ "not applicable"),
    method_combi = ifelse(
      method_cd == "PT",
      paste(method_cd, uv, level),
      paste(method_cd, spring_code)
    )
  ) %>%
  arrange(time_order, .by_group = TRUE) %>%
  mutate(
    time_since_previous = date_b - dplyr::lag(date_e),
    time_till_next = dplyr::lead(date_b) - date_e) %>%
  ungroup()
```

```{r}
glimpse(identifications)
glimpse(identifications_basic)
glimpse(samples)
glimpse(samples_basic)
glimpse(sampling_sites)
glimpse(naturalhistorytraits)
```


### Proefopzet

Er werden 5 verschillende monitoringsmethoden getest:

- 2 transecttypen. Een transect beslaat 500m en is verdeeld in 10 secties:
  - SPRING s.s.: waargenomen of op het zicht verzameld (TS - s.s.)
  - MP: verzameld via het afslepen van de vegetatie of bodem (TS - MP)

- 3 pan traps opstellingen. Eén pan trap sample is de gecombineerde vangst van één pan trap unit bestaande uit één blauwe, één witte en één gele val. Per transect worden steeds 10 units geplaatst, dus één per sectie:
  - UV-reflecterende pan traps op vegetatiehoogte geplaatst (PT - s.s.)
  - identieke samenstelling maar op de bodem geplaatst (PT - SSL)
  - niet-UV-reflecterende pan trap unit (wat grotere valtypes), zowel op vegetatiehoogte als op de bodem (PT - MP)
  
Deze methoden werden op drie verschillende locaties getest:
- BE_MVS01: Proefterrein ILVO
- BE_MVS02: Natuurgebied Bourgoyen-Ossemeersen in Gent
- BE_MVS03: Natuurgebied Den Dotter in Haaltert

Op locatie 1 werd op vraag van ILVO een 11de pan trap geplaatst, deze werd, buiten het algemeen overzicht van het aantal soorten, niet meegenomen in de analyses.

```{r}
angle2dec <- function(x) {
  x <- stringr::str_extract_all(x, pattern = "[\\d\\.]+")
  x <- lapply(x, as.numeric)
  x <- lapply(x, function(x) x[1] + x[2] / 60 + x[3] / 3600)
  x <- unlist(x)
  return(x)
}

transecten <- sampling_sites %>%
  filter(method_cd == "TS") %>%
  select(
    -sampling_site_id,
    -alt_exact_position,
    -alt_start_section,
    -alt_end_section,
    -lat_exact_position,
    -long_exact_position
  ) %>%
  mutate(
    long_start_section = angle2dec(long_start_section),
    lat_start_section = angle2dec(lat_start_section),
    long_end_section = angle2dec(long_end_section),
    lat_end_section = angle2dec(lat_end_section),
    geometry = sprintf(
      "LINESTRING (%s %s, %s %s)",
      long_start_section, lat_start_section, long_end_section, lat_end_section
    ),
    geometry = st_as_sfc(geometry)
  ) %>%
  select(-ends_with("section")) %>%
  mutate(transect_sectie = stringr::str_extract(remarks, "\\d*-\\d*m")) %>% 
  mutate(transect_sectie = factor(
    transect_sectie,
    levels = c(
      "0-50m",
      "50-100m",
      "100-150m",
      "150-200m",
      "200-250m",
      "250-300m",
      "300-350m",
      "350-400m",
      "400-450m",
      "450-500m"
    )
  )) %>%
  st_as_sf(crs = 4326)

glimpse(transecten)

pantraps <- sampling_sites %>%
  filter(method_cd == "PT") %>%
  select(
    -sampling_site_id,
    -alt_exact_position,
    -alt_start_section,
    -alt_end_section,
    -long_start_section,
    -lat_start_section,
    -long_end_section,
    -lat_end_section,
  ) %>%
  mutate(
    long_exact_position = angle2dec(long_exact_position),
    lat_exact_position = angle2dec(lat_exact_position),
    geometry = sprintf(
      "POINT (%s %s)",
      long_exact_position, lat_exact_position
    ),
    geometry = st_as_sfc(geometry)
  ) %>%
  select(-ends_with("_position"), -remarks) %>%
  st_as_sf(crs = 4326)

glimpse(pantraps)
```

We plotten de locaties van de transecten en pan traps om te controleren dat alles correct in de databank zit.

```{r map-transecten}
plottransecten <- function(x) {
  ggplot(x) +
    geom_sf(aes(colour = transect_sectie)) +
    labs(title = x$location_code[[1]])
}

transecten %>%
  nest(data = everything(), .by = location_code) %>%
  mutate(
    plot = map(
      .x = data,
      .f = plottransecten
    )
  ) %>%
  pull(plot)
```

```{r map-pantraps}
plotpantraps <- function(x) {
  ggplot(x) +
    geom_sf() +
    labs(title = x$location_code[[1]])
}
pantraps %>%
  nest(data = everything(), .by = location_code) %>%
  mutate(
    plot = map(
      .x = data,
      .f = plotpantraps
    )
  ) %>%
  pull(plot)
```


### Tijdsreeksen

Een subset van de pan trap opstellingen werd langer in het veld gelaten.

Voor locatie 1 en 2 hebben we een tijdsreeks per één of twee dagen. Van locatie 1 werd in September een tijdsreeks gemaakt, van locatie 2 en 3 in Juni. Voor locatie 3 hebben we geen tussenstappen, deze locatie kan dus niet gebruikt worden voor de rarefaction analyse (Tabel \@ref(tab:timeseries)).

```{r timeseries}
samples %>%
  filter(time_series == 1) %>%
  group_by(location_code, spring_code, level, date_b, date_e) %>%
  summarise(aantal_samples = n_distinct(sample_code)) %>%
  kable(caption = "Datums waarop de tijdsreeksen bemonsterd werden.")
```

# General overview

De figuren en tabellen in dit hoofdstuk geven een overzicht van alle waargenomen soorten (dus ook deze van de tijdsreeksen en de 11de locatie op de site van ILVO), met uitzondering van soortgroepen die tijdens de eerste grove sortering als restfractie beschouwd werden (mieren, kevers, spinnen, ...).

## Numbers per order

```{r, fig.cap = "Aantal soorten per order."}
identifications_basic %>%
  group_by(group, order) %>%
  summarise(n_species = n_distinct(species_nm, na.rm = TRUE)) %>%
  mutate(order = reorder(order, desc(n_species))) %>%
  plot_ly(
    x = ~order,
    y = ~n_species,
    color = ~group,
    type = "bar")
```

```{r, fig.cap = "Aantal individuen per order."}
identifications_basic %>%
  group_by(group, order) %>%
  summarise(n_individuals = sum(no_ind)) %>%
  mutate(order = reorder(order, desc(n_individuals))) %>%
  plot_ly(
    x = ~order,
    y = ~n_individuals,
    color = ~group,
    type = "bar")
```


## Numbers per family

```{r, fig.cap = "Aantal soorten per familie."}
identifications_basic %>%
  group_by(group, family) %>%
  summarise(n_species = n_distinct(species_nm, na.rm = TRUE)) %>%
  mutate(family = reorder(family, desc(n_species))) %>%
  plot_ly(
    x = ~family,
    y = ~n_species,
    color = ~group,
    type = "bar") %>%
  layout(xaxis = list(tickangle = -45))
```

```{r, fig.cap = "Aantal individuen per familie."}
identifications_basic %>%
  group_by(group, family) %>%
  summarise(n_individuals = sum(no_ind)) %>%
  mutate(family = reorder(family, desc(n_individuals))) %>%
  plot_ly(
    x = ~family,
    y = ~n_individuals,
    color = ~group,
    type = "bar") %>%
  layout(xaxis = list(tickangle = -45))
```

## Numbers per species

```{r species-num, results="asis"}
cat("<table><table width=100%>",paste0("<caption>", "(#tab:species-num)", "Aantal individuen per soort.", "</caption>"),"</table>", sep ="\n")

identifications %>%
  group_by(order, family, species_nm) %>%
  summarise(n_individuals = sum(no_ind, na.rm = TRUE)) %>%
  arrange(desc(n_individuals), species_nm) %>%
  DT::datatable()
```


# Data verkenning

```{r verkenning, results = "asis", eval = TRUE}
purrr::pmap(
  list(
    title = c("Wilde bijen (Apoidea)", "Zweefvliegen (Syrphidea)"),
    familyvec = c(
      'c(
        "Apidae", "Andrenidae",
        "Colletidae", "Halictidae",
        "Melittidae", "Megachilidae"
      )',
      'c("Syrphidae")'
    ),
    group = c("apoidea", "syrphidae")
  ),
  function(
    title = title, group = group, familyvec = familyvec
  ) {
    knit_expand(
      here::here("source", "_verkenning.Rmd"),
      title = title,
      group = group,
      familyvec = familyvec)
  }
) %>%
  paste(collapse = "\n") -> rmd

# onderstaande clipr code kan je gebruiken om de rmd naar klembord te schrijven
# daarna kan je dit plakken in een tijdelijk bestand en de chunks runnen
# enkel nodig indien je interactief werkt en de code van deze chunks nodig hebt
# clipr::write_clip(rmd)

knit(text = rmd, quiet = TRUE) %>%
  cat()
```


# Data modellering

## Soortenrijkdom

We fitten de modellen voor beide soortengroepen samengenomen in hetzelfde model, maar we laten elke covariaat in interactie gaan met de soortengroep zodat we aparte parameterschattingen per soortengroep bekomen.

We maken geen correctie voor het aantal gevangen individuen (door dit toe te voegen als covariaat): omwille van het hoge aantal gevallen waar er 0 soorten zijn (en dus 0 individuen) geeft deze correctie problemen in het model (0 individuen is een perfecte, maar ook onzinnige, voorspeller voor 0 soorten).

Gegevens van de tijdsreekens en de 11de pantrap op locatie 1 werden niet meegenomen in de modellen.

```{r}
data_sp_rich <- apoidea %>%
  mutate(taxgroup = "Apoidea") %>%
  bind_rows(
    syrphidae %>%
      mutate(taxgroup = "Syrphidae")
  ) %>%
  filter(time_series == 0) %>%
  mutate(
    maand = as.factor(month(date_b))) %>%
  group_by(
    sample_code, location_code, method_combi, 
    method_cd, spring_code, uv, level, maand, taxgroup) %>%
  summarise(
    n_species = n_distinct(species_nm, na.rm = TRUE),
    n_ind = sum(no_ind),
    .groups = "drop"
  )
```

### SPRING protocol

Het eerste model heeft enkel betrekking op de SPRING methode sensu stricto. 

```{r}
data_sp_rich_spring <- data_sp_rich %>%
  filter(spring_code == "s.s.")
```


```{r, fig.cap = "Aantal keren dat n aantal soorten in één pan trap of subtransect van 50m gevonden werd."}
ggplot(data_sp_rich_spring, aes(x = n_species)) +
  geom_histogram(
    aes(fill = taxgroup),
    position = position_dodge())
```


```{r, fig.cap = "Aantal individuen in één pan trap of subtransect van 50m ten opzichte van het aantal soorten in die pan trap of dat subtransect."}
ggplot(data_sp_rich_spring) +
  geom_point(aes(x = n_ind, y = n_species)) +
  facet_wrap(~ taxgroup, scales = "free")
```

```{r}
model0 <- glmmTMB(
  n_species ~ 
    (location_code
  + maand
  + method_cd) * taxgroup
  ,
  family = "poisson",
  ziformula = ~ taxgroup,
  na.action = na.fail,
  data = data_sp_rich_spring
)
```

```{r check1, fig.height=12, fig.cap = "Visuele controle van verschillende modelaannames."}
performance::check_model(model0)
```

```{r, fig.cap = "Verwacht aantal soorten per maand, soortgroep en SPRING methode op basis van ons model."}
marginaleffects::plot_predictions(
  model0,
  condition = c("maand", "method_cd",  "taxgroup"),
  type = "response",
  vcov = TRUE
)
```

### Alternatieve methoden

1. Leveren transecttellingen een andere diversiteit op dan pan trap opstellingen?
2. Leveren transsecttellingen on sight (visual) een hogere diversiteit op dan de MP-transecttellingen?
3. Leveren de pan trap units op vegetatiehoogte een hogere diversiteit op dan de andere UV-pan traps op grondniveau?
4. Leveren de UV-pan trap units een hogere diversiteit op dan de niet-UV-reflecterende pan traps? (eventueel kan er ook naar het gecombineerd effect vegetatiehoogte*UV-reflectie gekeken worden)

Interactie tussen uv en hoogte van plaatsing kan niet onderzocht worden omdat er geen niet-uv traps op vegetatieniveau geplaatst werden.

```{r}
model1 <- glmmTMB(
  n_species ~
    (method_combi
  + location_code
  + maand
  ) * taxgroup,
  ziformula = ~ taxgroup,
  family = "poisson", 
  na.action = na.exclude,
  data = data_sp_rich
)
```

De hoge waarden voor collineariteit (Fig. \@ref(fig:check2)) zijn in dit geval geen probleem en zijn het gevolg van (verwachte) collineariteit t.g.v. toevoegen van interacties.

```{r check2, fig.height=12, fig.cap = "Visuele controle van verschillende modelaannames."}
performance::check_model(model1)
```

```{r, fig.cap = "Verwacht aantal soorten per soortgroep en methode op basis van ons model."}
marginaleffects::plot_predictions(
  model1,
  condition = c("method_combi", "taxgroup"),
  type = "response",
  vcov = TRUE,
  draw = FALSE) %>%
  left_join(
    data_sp_rich %>%
      distinct(method_cd, spring_code, uv, level, method_combi, taxgroup)
  ) %>%
  as_tibble() %>%
  ggplot() +
  geom_pointrange(
    aes(
      x = method_cd, y = estimate, ymin = conf.low, ymax = conf.high,
      colour = method_combi),
    position = position_dodge(width = 0.5)
  ) +
  labs(y = "Soortenrijkdom") +
  facet_wrap(~taxgroup, scales = "free")
```

## Alpha biodiversity

De Shannon index wordt als volgt berekend:
$$H' = - \sum_{i=1}^{R} p_i ln p_i$$
Waarbij $p_i$ de proportie is van het aantal individuen van één soort ten opzichte van het totaal aantal individuen.

Er kan geen Shannon index berekent worden voor pan traps of deeltransecten waarin niks gevangen werd. Het gebruik van deze index leidt dus sowieso tot een verlies aan informatie. Daarnaast is de Shannon index van een sample waar slechts één soort gevonden wordt gelijk aan 0.

```{r}
sha <- apoidea %>%
  mutate(taxgroup = "Apoidea") %>%
  bind_rows(
    syrphidae %>%
      mutate(taxgroup = "Syrphidae")
  ) %>% 
  group_by(sampling_site_cd, spring_code, method_cd, taxgroup,
           location_code, method_combi) %>% 
  mutate(tot_ind = sum(no_ind)) %>% 
  group_by(sampling_site_cd, spring_code, 
           method_cd, species_nm, tot_ind,
           taxgroup,
           location_code, method_combi) %>% 
  summarise(n_ind = sum(no_ind)) %>% 
  mutate(prop = (n_ind/tot_ind) * log(n_ind/tot_ind)) %>% 
  group_by(sampling_site_cd, spring_code, 
           method_cd, taxgroup,
           location_code, method_combi) %>% 
  summarise(exp_sh = exp(-sum(prop, na.rm = TRUE)))
```

```{r, fig.cap = "Shannon index (exp) per pan trap of subtransect van 50m."}
ggplot(sha, aes(x = exp_sh)) +
  geom_histogram(
    aes(fill = taxgroup),
    position = position_dodge())
```

```{r}
model0 <- glmmTMB(
  exp_sh ~ 
    (method_combi +
       location_code) * taxgroup
  ,
  family = "Gamma",
  ziformula = ~ taxgroup,
  na.action = na.fail,
  data = sha
)
```

```{r check3, fig.height=10, fig.cap = "Visuele controle van verschillende modelaannames."}
performance::check_model(model0)
```

```{r, fig.cap = "Verwachte Shannon index (exp) per soortgroep en methode op basis van ons model."}
marginaleffects::plot_predictions(
  model0,
  condition = c("method_combi",  "taxgroup"),
  type = "response",
  vcov = TRUE
)
```

# Kosten

```{r}
cost_data <- read_sheet("https://docs.google.com/spreadsheets/d/179lN4oWz6jnKx4z6MTw5S8oI8B5iYxRmbNoStl9Ywf0", 
                        sheet = "Kosten")

time_data <- read_sheet("https://docs.google.com/spreadsheets/d/179lN4oWz6jnKx4z6MTw5S8oI8B5iYxRmbNoStl9Ywf0", 
                        sheet = "Tijdsbesteding")

time_data <- time_data %>% 
  left_join(cost_data %>% 
              select(ID, `prijs/min`),
            by = join_by(uitvoerder == ID))

time_data <- time_data %>% 
  mutate(kost = minuten * `prijs/min`)

```

```{r}
verpl <- cost_data %>% 
  filter(Kostencategorie == "Gemiddelde afstand SPRING locaties") %>% 
  pull(prijs) *
  cost_data %>% 
  filter(Kostencategorie == "Km vergoeding") %>% 
  pull(prijs)
```

Ervan uitgaand dat de gemiddelde verplaatsing naar een locatie 35.25 km bedraagt betalen we aan kilometervergoeding `r round(verpl)` euro.

```{r}
verpl_tijd <- cost_data %>% 
  filter(Kostencategorie == "Gemiddelde afstand SPRING locaties") %>% 
  pull(prijs) / 50 * 60

loon_verpl <- cost_data %>% 
  filter(Kostencategorie == "Jaarloon veldmedewerker") %>% 
  pull(`prijs/min`)
```

Om deze afstand te rijden hebben we `r round(verpl_tijd)` minuten nodig. Als dit door een veldmedewerker gebeurt dan kost ons dit `r round(verpl_tijd * loon_verpl)` euro in loonkost.




Variabele kosten pan traps:
```{r}
time_data %>% 
  filter(methode == "PT") %>% 
  summarise(.by = submethode, prijs = sum(kost)) %>% 
  add_row(cost_data %>% filter(!is.na(submethode)) %>% 
            select(submethode, prijs)) %>% 
  summarise(.by = submethode, prijs = sum(prijs)) %>%
  kableExtra::kable()
```


Variabele kosten transecten:
```{r}
time_data %>% 
  filter(methode == "TS") %>% 
  summarise(.by = submethode, prijs = sum(kost)) %>%
  kableExtra::kable()
```

## Scenario's

```{r}
calculate_costs <- function(points, method, submethod){
  cost1 <- time_data %>% 
  filter(methode == method,
         submethode == submethod) %>% 
  summarise(prijs = sum(kost)) %>% 
    pull(prijs)
  
  cost2 <- cost_data %>% 
    filter(!is.na(submethode),
           methode == method,
           submethode == submethod) %>% 
    summarise(prijs = sum(prijs)) %>% 
    pull(prijs)
  
  ((cost1 + cost2) * points)
}
```


Scenario 1:

- 650 meetpunten
- 1 pan trap s.s. per locatie

```{r}
calculate_costs(650, "PT", "s.s.") +
  (650 * 14.93543) + (650 * 36.27281)
```

Scenario 2:

- 650 meetpunten
- Transect (sweeping) van 250m

```{r}
calculate_costs(650, "TS", "MP") * 5 +
  (650 * 14.93543) + (650 * 36.27281)
```

Scenario 3:

- 650 meetpunten
- 1 pan trap s.s. per locatie
- Transect (sweeping) van 250m

```{r}
calculate_costs(650, "PT", "s.s.") +
  calculate_costs(650, "TS", "MP") * 5 +
  (650 * 14.93543) + (650 * 36.27281)
```

<!--
# Correspondence Analysis

```{r, eval=FALSE}
library("FactoMineR")
library("factoextra")

cont_ap <- xtabs(no_ind ~ sample_code + family, apoidea)

chisq.test(cont_ap)

ca_ap <- CA(cont_ap)

fviz_ca_row(ca_ap)
```

```{r eval=FALSE}
ca_ap <- cca(cont_ap)

inboggvegan::ggbiplot_vegan(ca_ap)

ap <- apoidea %>%
  filter(!is.na(species_nm)) %>%
  arrange(sample_code) %>%
  distinct(method_cd, sample_code)

ca_ap <- cca(cont_ap ~ method_cd, data = ap)

inboggvegan::ggbiplot_vegan(ca_ap)
```


# Extra grafieken

```{r}
apoidea %>%
  filter(
    method_cd == "PT",
    spring_code == "s.s.",
    time_series == 0
  ) %>%
  arrange(sampling_site_cd) %>%
  group_by(location_code, species_nm) %>%
  mutate(var_temp = ifelse(row_number() == 1, 1, 0)) %>%
  group_by(location_code) %>%
  mutate(var2 = cumsum(var_temp)) %>%
  select(-var_temp) %>%
  group_by(location_code, sampling_site_cd) %>%
  summarise(cumsum = max(var2)) %>%
  mutate(point = str_sub(sampling_site_cd, -4, -1)) %>%
  ungroup() %>%
  ggplot(aes(
    x = point,
    y = cumsum,
    group = location_code,
    color = location_code
  )) +
  geom_point() +
  geom_line()
```

```{r}
apoidea %>%
  filter(
    method_cd == "PT",
    spring_code == "s.s.",
    time_series == 0
  ) %>%
  arrange(date_b) %>%
  group_by(location_code, species_nm) %>%
  mutate(var_temp = ifelse(row_number() == 1, 1, 0)) %>%
  group_by(location_code) %>%
  mutate(var2 = cumsum(var_temp)) %>%
  select(-var_temp) %>%
  group_by(location_code, date_b) %>%
  summarise(cumsum = max(var2)) %>%
  ungroup() %>%
  ggplot(aes(
    x = date_b,
    y = cumsum,
    group = location_code,
    color = location_code
  )) +
  geom_point() +
  geom_line()
```


```{r}
apoidea %>%
  filter(time_series == 0) %>%
  group_by(date_b) %>%
  mutate(n_species = n_distinct(species_nm, na.rm = TRUE)) %>%
  ggplot(aes(
    x = date_b,
    y = n_species,
    group = location_code,
    color = location_code
  )) +
  geom_point() +
  geom_line()
```

Modelleren:
shannon: normale, log-normale, gamma verdeling
soortendiv: poisson verdeling


1) Leveren transecttellingen een andere diversiteit op dan pan trap opstellingen (mogelijk
kan hiervoor een alpha biodiversity index toegepast worden)? exp shannon

tijdsreeks == 0
y ~ methode + maand + locatie + eventuele interacties

2) Leveren transsecttellingen on sight (visual) een hogere diversiteit op dan de MP-
transecttellingen?

tijdsreeks == 0
y ~ methode + submethode (+ interactie?) + maand + locatie + eventuele interacties

3) Leveren de pan trap units op vegetatiehoogte een hogere diversiteit op dan de andere UV-
pan traps op grondniveau?

y ~ methode + submethode (+ interactie?)   + maand + locatie + eventuele interacties

4) Leveren de UV-pan trap units een hogere diversiteit op dan de niet-UV-reflecterende pan
traps? (eventueel kan er ook naar het gecombineerd effect vegetatiehoogte*UV-reflectie
gekeken worden)

subset = pantraps
y ~ methode + is_bodem + is_uv  + maand + locatie + eventuele interacties

5) Hoe complementair zijn de verschillende protocols, op gebied van soorten?

- per soortengroep
    - vendiagram
    - tabel unieke soorten per methode + gemeenschappelijke soorten
    - indirecte ordinatie (CA + achteraf visualiseren kleur = methode )


6) Na hoeveel tijd wordt een saturatie bereikt bij de pan trap opstellingen, zowel in tijd (zie tijdsreeksen) als in aantal pan traps (van 1 tot 10 per monitoringsronde)?

subset = pantrap | tijdsreeksen
wellicht best apart per locatie

rarefaction curves per maandxlocatie

7) Hoe is het verloop van de diversiteit aan pollinatoren in de loop van het jaar (mei-
september)?



8) Is de pollinatorgemeenschap van landbouwgebied (MVS01 - ILVO) armer of rijker dan
die van meer natuurlijk landschap (MVS02 en 03)?

tijdsreeks == 0
y ~ methode + maand + locatie + eventuele interacties

rarefaction: vegan spec.accum, inext




# Zweefvliegen (Syrphidea)

## Modelleren

### Soortenrijkdom

```{r}
syr_data_sp_rich <- syrphidae %>%
  group_by(sample_code) %>%
  mutate(n_species = n_distinct(species_nm, na.rm = TRUE)) %>%
  filter(time_series == 0) %>%
  mutate(
    maand = as.factor(month(date_b)),
    n_species = ifelse(is.na(n_species), 0, n_species)
  ) %>%
  select(location_code, method_cd, spring_code, level, maand, n_species) %>%
  mutate(uv = ifelse(spring_code == "MP", "non-uv", "uv"))
```

```{r}
ggplot(syr_data_sp_rich, aes(x = n_species)) +
  geom_histogram()
```

```{r}
model0 <- glmmTMB(n_species ~ location_code + maand,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = syr_data_sp_rich
)

summary(model0)
```

```{r, fig.height=10}
performance::check_model(model0)
```

```{r}
marginaleffects::plot_predictions(
  model0,
  condition = c("maand", "location_code"),
  type = "response",
  vcov = TRUE
)
```

1) Leveren transecttellingen een andere diversiteit op dan pan trap opstellingen?

```{r}
model1 <- glmmTMB(n_species ~ method_cd + location_code + maand,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = syr_data_sp_rich
)

summary(model1)
```

```{r, fig.height=10}
performance::check_model(model1)
```

```{r}
marginaleffects::plot_predictions(
  model1,
  condition = c("maand", "method_cd", "location_code"),
  type = "response",
  vcov = TRUE
)
```

2) Leveren transsecttellingen on sight (visual) een hogere diversiteit op dan de MP-
transecttellingen?

```{r}
model2 <- glmmTMB(n_species ~ spring_code + location_code + maand,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = syr_data_sp_rich %>% filter(method_cd == "TS")
)

summary(model2)
```

```{r, fig.height=10}
performance::check_model(model2)
```

```{r}
marginaleffects::plot_predictions(
  model2,
  condition = c("maand", "spring_code", "location_code"),
  type = "response",
  vcov = TRUE
)
```

3) Leveren de pan trap units op vegetatiehoogte een hogere diversiteit op dan de andere UV-pan traps op grondniveau?

4) Leveren de UV-pan trap units een hogere diversiteit op dan de niet-UV-reflecterende pan traps? (eventueel kan er ook naar het gecombineerd effect vegetatiehoogte*UV-reflectie gekeken worden)

Interactie kan niet onderzocht worden omdat er geen niet-uv traps op vegetatieniveau geplaatst werden.

```{r}
model3 <- glmmTMB(n_species ~ uv + level + location_code + maand,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = syr_data_sp_rich %>% filter(method_cd == "PT")
)

summary(model3)
```

```{r, fig.height=10}
performance::check_model(model3)
```

```{r}
marginaleffects::plot_predictions(
  model3,
  condition = c("level", "uv"),
  type = "response",
  vcov = TRUE
)
```

## Correspondence Analysis

```{r, eval=FALSE}
library("FactoMineR")
library("factoextra")

cont_ap <- xtabs(no_ind ~ sample_code + species_nm, syrphidae)

chisq.test(cont_ap)

ca_ap <- CA(cont_ap)

fviz_ca_row(ca_ap)
```

```{r eval=FALSE}
syr <- syrphidae %>%
  filter(!is.na(species_nm)) %>%
  arrange(sample_code) %>%
  distinct(method_cd, sample_code)

ca_ap <- cca(cont_ap ~ method_cd, data = syr)

inboggvegan::ggbiplot_vegan(ca_ap)
```


# Gecombineerde analyses

```{r}
expanded_samples <- samples %>%
  mutate(group = "Apoidae") %>%
  add_row(samples %>% mutate(group = "Syrphidae"))


polli <- identifications %>%
  filter(family %in% c(
    "Apidae", "Andrenidae",
    "Colletidae", "Halictidae",
    "Melittidae", "Megachilidae",
    "Syrphidae"
  )) %>%
  mutate(group = ifelse(family == "Syrphidae", "Syrphidae", "Apoidae")) %>%
  full_join(expanded_samples, by = c("sample_id", "sample_code", "group")) %>%
  mutate(
    no_ind = ifelse(is.na(no_ind), 0, no_ind),
    maand = as.factor(month(date_b)),
    uv = ifelse(spring_code == "MP", "non-uv", "uv")
  ) %>%
  mutate(numbered_value = as.numeric(str_sub(sampling_site_cd, -2, -1))) %>%
  filter(
    numbered_value < 11,
    time_series == 0
  ) %>%
  group_by(
    location_code, method_cd, spring_code, level, maand,
    group, uv, sample_code
  ) %>%
  summarise(
    n_species = n_distinct(species_nm, na.rm = TRUE),
    n_ind = sum(no_ind)
  )
```

```{r}
model0 <- glmmTMB(n_species ~ location_code + maand + n_ind + group,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = polli
)

summary(model0)
```

```{r, fig.height=10}
performance::check_model(model0)
```

```{r}
marginaleffects::plot_predictions(
  model0,
  condition = c("maand", "location_code"),
  type = "response",
  vcov = TRUE
)
```

1) Leveren transecttellingen een andere diversiteit op dan pan trap opstellingen?

```{r}
model1 <- glmmTMB(n_species ~ method_cd * group + location_code + maand + n_ind,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = polli
)

summary(model1)
```

```{r, fig.height=10}
performance::check_model(model1)
```

```{r}
marginaleffects::plot_predictions(
  model1,
  condition = c("maand", "group", "method_cd"),
  type = "response",
  vcov = TRUE
)
```

2) Leveren transsecttellingen on sight (visual) een hogere diversiteit op dan de MP-
transecttellingen?

```{r}
model2 <- glmmTMB(
  n_species ~ spring_code * group + location_code +
    maand + n_ind,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = polli %>% filter(method_cd == "TS")
)

summary(model2)
```

```{r, fig.height=10}
performance::check_model(model2)
```

```{r}
marginaleffects::plot_predictions(
  model2,
  condition = c("maand", "group", "spring_code"),
  type = "response",
  vcov = TRUE
) + facet_wrap("spring_code", scales = "fixed")
```

3) Leveren de pan trap units op vegetatiehoogte een hogere diversiteit op dan de andere UV-pan traps op grondniveau?

4) Leveren de UV-pan trap units een hogere diversiteit op dan de niet-UV-reflecterende pan traps? (eventueel kan er ook naar het gecombineerd effect vegetatiehoogte*UV-reflectie gekeken worden)

Interactie kan niet onderzocht worden omdat er geen niet-uv traps op vegetatieniveau geplaatst werden.

```{r}
model3 <- glmmTMB(
  n_species ~ uv * group + level * group +
    location_code + maand + n_ind,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = polli %>% filter(method_cd == "PT")
)

summary(model3)
```

```{r, fig.height=10}
performance::check_model(model3)
```

```{r}
marginaleffects::plot_predictions(
  model3,
  condition = c("level", "uv", "group"),
  type = "response",
  vcov = TRUE
)
```

Vergelijk alle methoden in één model

```{r}
model4 <- glmmTMB(
  n_species ~ c_meth * group +
    location_code + maand + n_ind,
  family = "poisson",
  ziformula = ~1,
  na.action = na.exclude,
  data = polli %>%
    mutate(c_meth = str_c(method_cd, spring_code,
      sep = "", collapse = NULL
    ))
)

summary(model4)
```

```{r, fig.height=10}
performance::check_model(model4)
```

```{r}
marginaleffects::plot_predictions(
  model4,
  condition = c("c_meth", "group"),
  type = "response",
  vcov = TRUE
)
```

Vergelijk beste methode PT met beste methode TS

```{r}
```









-->
